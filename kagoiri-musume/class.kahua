;; -*- coding: euc-jp; mode: scheme -*-
;;
;;  Copyright (c) 2005 Kahua.Org, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: class.kahua,v 1.16 2005/10/01 06:20:17 shibata Exp $
;;
;; include
;;(load "kagoiri-musume/version.kahua")
(load "kagoiri-musume/local.kahua")
;;
;(use srfi-13)
;(use util.list)
;(use gauche.collection)

;; Unit means Project.
;;
(define-class <unit> (<kahua-persistent-base>)
  (
   ;; unit name means project name.
   (unit-name       :allocation :persistent :init-keyword :unit-name
		    :accessor unit-name-of)
   (description     :allocation :persistent :init-keyword :description
		    :init-value "" :accessor description-of)
   ;; counter of musume as issue.
   (next-musume-no  :allocation :persistent :init-keyword :next-musume-no
		    :init-value 1)
   ;; fans means developers.
   (fans            :allocation :persistent :init-keyword :fans
		    :init-value '() :accessor fans-of)
   ;; priorities
   (priorities      :allocation :persistent :init-keyword :priorities
		    :init-value '() :accessor priorities-of)
   ;; statuss
   (statuss         :allocation :persistent :init-keyword :statuss
		    :init-value '() :accessor statuss-of)
   ;; types
   (types           :allocation :persistent :init-keyword :types
		    :init-value '() :accessor types-of)
   ;; categories
   (categories      :allocation :persistent :init-keyword :categories
		    :init-value '() :accessor categories-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time)
   ;; delete flag
   (fallout         :allocation :persistent :init-keyword :fallout
		    :init-value #f :accessor fallout-of)
   ))

;; comment
#|
(define-method key-of ((self <unit>))
  (unit-name-of self))
|#

;; データ移行向け
(define-method initialize ((obj <unit>) initargs)
  (next-method)
  (let ((attr (append (fans-of obj)
		      (priorities-of obj)
		      (statuss-of obj)
		      (types-of obj)
		      (categories-of obj))))
    (if (and (not (null? attr))
	     (is-a? (car attr) <string>))
	(begin
	  (set! (fans-of obj) (map (lambda (f)
				     (find-kahua-instance <fan-property> f))
				   (fans-of obj)))
	  (set! (priorities-of obj) (map (lambda (p)
					   (find-kahua-instance <priority> p))
					 (priorities-of obj)))
	  (set! (statuss-of obj) (map (lambda (s)
					(find-kahua-instance <status> s))
				      (statuss-of obj)))
	  (set! (types-of obj) (map (lambda (t)
				      (find-kahua-instance <type> t))
				    (types-of obj)))
	  (set! (categories-of obj) (map (lambda (c)
					   (find-kahua-instance <category> c))
					 (categories-of obj)))
	  ))))

(define (active? unit)
  (not (ref unit 'fallout)))

(define (all-units)
  (filter active?
	  (make-kahua-collection <unit>)))

(define (unit-exist? unit-id)
  (if (find-kahua-instance <unit> unit-id) #t #f))

;; Musume means issue.
;;
(define-class <musume> (<kahua-persistent-base>)
  (
   ;; back pointer for unit
   ;; DSC *** unit-id->unit ***
   (unit-id         :allocation :persistent :init-keyword :unit-id
		    :accessor unit-id-of)
   ;; musume-no means issue number.
   (musume-no       :allocation :persistent :init-keyword :musume-no
		    :init-value #f :accessor mno-of)
   ;; issue title
   (musume-name     :allocation :persistent :init-keyword :musume-name
		    :init-value "" :accessor mname-of)
   ;; issue priority
   ;; normal above-normal low high super
   (priority        :allocation :persistent :init-keyword :priority
		    :init-value "normal" :accessor priority-of)
   ;; status
   ;; open completed on-hold taken rejected
   (status          :allocation :persistent :init-keyword :status
		    :init-value "open" :accessor status-of)
   ;; type
   ;; discuss request bug report task term etc
   (type            :allocation :persistent :init-keyword :type
		    :init-value #f :accessor type-of)
   ;; category
   ;;
   (category        :allocation :persistent :init-keyword :category
		    :initi-value #f :accessor category-of)
   ;; assign
   (assign          :allocation :persistent :init-keyword :assign
		    :init-value #f :accessor assign-of)
   ;; musics
   (musics          :allocation :persistent :init-keyword :musics
		    :init-value '() :accessor musics-of)
   ;; create time
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time)
   ))

(define-method initialize ((obj <musume>) initargs)
  (next-method)
  ;; データ移行用
  (if (is-a? (unit-id-of obj) <string>)
      (begin
	(set! (unit-id-of obj)
	      (find-kahua-instance <unit> (unit-id-of obj)))
	(set! (priority-of obj)
	      (find-kahua-instance <priority> (priority-of obj)))
	(set! (status-of obj)
	      (find-kahua-instance <status> (status-of obj)))
	(set! (type-of obj)
	      (find-kahua-instance <type> (type-of obj)))
	(set! (category-of obj)
	      (find-kahua-instance <category> (category-of obj)))
	(set! (assign-of obj)
	      (find-kahua-instance <fan-property> (assign-of obj)))
	(set! (musics-of obj)
	      (map (lambda (id)
		     (find-kahua-instance <music> id))
		   (musics-of obj)))))
  (let* ((unit (unit-id-of obj)) ;;DSC *** unit-id-of -> unit-of
	 (mno (slot-ref unit 'next-musume-no)))
    ;; for restart
    (if (not (mno-of obj))
	(begin
	  (set! (slot-ref obj 'musume-no) mno)
	  (set! (slot-ref unit 'next-musume-no) (+ mno 1))))))

(define-method next-seq-no ((obj <musume>))
  (+ 1 (length (musics-of obj))))

;; 旧データ向け
(define-method all-musumes ((unit-id <string>))
  (filter (lambda (m)
	    (equal? unit-id (unit-id-of m)))
	  (make-kahua-collection <musume>)))

;; 新データ対応
(define-method all-musumes ((unit <unit>))
  (filter (lambda (m)
	    (eq? unit (unit-id-of m)))
	  (make-kahua-collection <musume>)))


#|
(define (all-musumes unit-id)
  (filter (lambda (m)
	    (equal? unit-id (unit-id-of m)))
	  (make-kahua-collection <musume>)))
|#

;; music means one of issue.
;;
(define-class <music> (<kahua-persistent-base>)
  (;; music-idは不要になる
   (music-id        :allocation :persistent :init-keyword :music-id
		    :init-value #f :accessor music-id-of)
   (seq-no          :allocation :persistent :init-keyword :seq-no
		    :init-value #f :accessor seq-no-of)
   ;; back pointer
   ;; which is value of (key-of <musume>)
   ;; DSC *** musume-id -> musume
   (musume-id       :allocation :persistent :init-keyword :musume-id
		    :accessor musume-id-of)
   (melody          :allocation :persistent :init-keyword :melody
		    :accessor melody-of)
   ;; DSC *** fan-id->fan
   (fan-id          :allocation :persistent :init-keyword :fan-id
		    :init-value #f :accessor fan-id-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time)
   ))

(define-method initialize ((obj <music>) initargs)
  (next-method)
  ;; データ移行向け
  (if (is-a? (musume-id-of obj) <string>)
      (begin
	(set! (musume-id-of obj)
	      (find-kahua-instance <musume> (musume-id-of obj)))
	(set! (fan-id-of obj)
	      (find-kahua-instance <fan-property> (fan-id-of obj)))))
  (let* ((musume (musume-id-of obj))
	 (musics (musics-of musume)))
    ;; for restart
    (if (not (music-id-of obj))
	(begin
	  (set! (music-id-of obj) (key-of obj))
	  (set! (seq-no-of obj) (next-seq-no musume))
	  (set! (musics-of musume)
		(cons (key-of obj) musics))))))

;; 旧データ向け
(define-method all-musics ((musume-id <string>))
  (and-let* ((musume (find-kahua-instance <musume> musume-id)))
    (map (lambda (id)
	   (find-kahua-instance <music> id))
	 (musics-of musume))))

;; 新データ向け
(define-method all-musics ((musume <musume>))
  (musics-of musume))
  

#|
(define (all-musics musume-id)
  (and-let* ((musume (find-kahua-instance <musume> musume-id)))
    (map (lambda (id)
	   (find-kahua-instance <music> id))
	 (musics-of musume))))
|#

;; fans means developer
;;
(define-class <fan-property> (<kahua-persistent-base>)
  (
   ;; fan-name equal <kahua-user> login-name
   ;; so, this property needs a instance of <kahua-user>.
   (fan-name        :allocation :persistent :init-keyword :fan-name
		    :init-value #f :accessor fan-name-of)
   (email           :allocation :persistent :init-keyword :email
		    :init-value #f :accessor email-of)
   ;; delete flag
   (delete          :allocation :persistent :init-keyword :delete
		    :init-value #f :accessor get-delete-flag)
   ))

;; comment
(define-method key-of ((self <fan-property>))
  (fan-name-of self))


(define (lucky-fan? fan-prop)
  (not (ref fan-prop 'delete)))

(define (all-fans)
  (map fan-name-of
       (filter lucky-fan?
	       (make-kahua-collection <fan-property>))))

(define (add-fan name passwd email . roles)
  (and-let* ((user (kahua-add-user name passwd))
	     (fanp (make <fan-property>
		     :fan-name name :email email)))
    ; In fact, admin role only supported.
    (set! (ref user 'role-alist) roles)
    user))

;; 旧データ向け
(define-method fan-to? ((unit-id <string>) (fan-name <string>))
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member fan-name (fans-of unit))))
    (if include? #t #f)))

;; 新データ向け
(define-method fan-to? ((unit <unit>) (fan <fan-property>))
  (if (member fan (fans-of unit)) #t #f))


#|
(define (fan-to? unit-id fan-name)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member fan-name (fans-of unit))))
    (if include? #t #f)))
|#

;; priority property
;;
(define-class <priority> (<kahua-persistent-base>)
  ((priorityid       :allocation :persistent :init-keyword :priorityid
		     :accessor priorityid-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (level            :allocation :persistent :init-keyword :level
		     :init-value 0 :accessor level-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)))

;; comment
(define-method key-of ((self <priority>))
  (priorityid-of self))


(define-method enable? ((obj <priority>))
  (not (ref obj 'delete)))

(define (all-priorities)
  (filter enable? (make-kahua-collection <priority>)))

;; 旧データ向け
(define-method has-priority? ((unit-id <string>) priority)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member priority (priorities-of unit))))
    (if include? #t #f)))

;; 新データ向け
(define-method has-priority? ((unit <unit>) priority)
  (if (member priority (priorities-of unit)) #t #f))


#|
(define (has-priority? unit-id priority)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member priority (priorities-of unit))))
    (if include? #t #f)))
|#

;; status property
;;
(define-class <status> (<kahua-persistent-base>)
  ((statusid         :allocation :persistent :init-keyword :statusid
		     :accessor statusid-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)))

;; comment
(define-method key-of ((self <status>))
  (statusid-of self))


(define-method enable? ((obj <status>))
  (not (ref obj 'delete)))

(define (all-statuss)
  (filter enable? (make-kahua-collection <status>)))

;; 旧データ向け
(define-method has-status? ((unit-id <string>) status)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member status (statuss-of unit))))
    (if include? #t #f)))

;; 新データ向け
(define-method has-status? ((unit <unit>) status)
  (if (member status (statuss-of unit)) #t #f))

#|
(define (has-status? unit-id status)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member status (statuss-of unit))))
    (if include? #t #f)))
|#

;; type property
;;
(define-class <type> (<kahua-persistent-base>)
  ((typeid           :allocation :persistent :init-keyword :typeid
		     :accessor typeid-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)))

;; comment
(define-method key-of ((self <type>))
  (typeid-of self))


(define-method enable? ((obj <type>))
  (not (ref obj 'delete)))

(define (all-types)
  (filter enable? (make-kahua-collection <type>)))

;; 旧データ向け
(define-method has-type? ((unit-id <string>) type)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member type (types-of unit))))
    (if include? #t #f)))

;; 新データ向け
(define-method has-type? ((unit <unit>) type)
  (if (member type (types-of unit)) #t #f))

#|
(define (has-type? unit-id type)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member type (types-of unit))))
    (if include? #t #f)))
|#

;; categories property
;;
(define-class <category> (<kahua-persistent-base>)
  ((categoryid       :allocation :persistent :init-keyword :categoryid
		     :accessor categoryid-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)))

;; comment
(define-method key-of ((self <category>))
  (categoryid-of self))


(define-method enable? ((obj <category>))
  (not (ref obj 'delete)))

(define (all-categories)
  (filter enable? (make-kahua-collection <category>)))

;; 旧データ向け
(define-method has-category? ((unit-id <string>) category)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member category (categories-of unit))))
    (if include? #t #f)))

;; 新データ向け
(define-method has-category? ((unit <unit>) category)
  (if (member category (categories-of unit)) #t #f))

#|
(define (has-category? unit-id category)
  (and-let* ((unit (find-kahua-instance <unit> unit-id))
	     (include? (member category (categories-of unit))))
    (if include? #t #f)))
|#